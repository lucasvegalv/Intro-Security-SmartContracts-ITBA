const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Ejercicio 4", function () {

  let deployer, usuario, atacante;

  beforeEach(async function () {

    [deployer, atacante, usuario] = await ethers.getSigners();

    // Deployamos el contrato King con la cuenta "deployer"
    const King = await ethers.getContractFactory("King", deployer);
    this.contratoKing = await King.deploy({ value: ethers.utils.parseEther('1') });

    // El rey ahora es el deployer
    expect(await this.contratoKing.king()).to.eq(deployer.address);

    // Un usuario envía ETH al contrato para convertirse en el nuevo rey
    await usuario.sendTransaction({
        to: this.contratoKing.address,
        value: ethers.utils.parseEther('1.5')
    });
    expect(await this.contratoKing.king()).to.eq(usuario.address);
  });

  it.skip('Ataque', async function () {
    // COMPLETAR
    // ¿Atacar desde EOA o contrato? ¿Por qué?
    // Si es contrato, ¿cómo deployamos ese contrato? ¿Qué hay que enviar al contrato?
    // ¿Cómo podemos verificar que efectivamente el ataque tuvo éxito?
    // ¿Dónde conviene incluir esas verificaciones?
  });

  afterEach(async function () {
    await expect(usuario.sendTransaction({
        to: this.contratoKing.address,
        value: ethers.utils.parseEther('10')
    })).to.be.revertedWith(
        "Transaction reverted: function selector was not recognized and there's no fallback nor receive function"
    );

    expect(await this.contratoKing.king()).to.not.eq(usuario.address);
  });
});
